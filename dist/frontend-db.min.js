!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).FrontendDB=t()}(this,(function(){"use strict";function e(e,t){if(!t)return e;var r=[],s=new Set(e);return t.forEach((function(e){s.has(e)&&r.push(e)})),r}const t=["getIndexes","copy","addRecord","clearAllRecords","getRecord","getAllRecords","getAllKeys","getAllRecordsWithKeys","existsRecord","deleteRecord","updateRecord","searchRecords","searchRecordsAdvanced"];class r{constructor(e,t,r){this.db=e,this.name=t,this.schema=r,this.idbObjectStore=null,this.definePublicMethods()}definePublicMethods(){for(var e of t)this[e]=this.db.getPublicMethodFunction(this["_"+e],this)}async _prepare(e="readonly"){this.idbObjectStore=await this.db.getIDBObjectStore(this.name,e)}async _getIndexes(){return await this._prepare(),this.idbObjectStore.indexNames}async _copy(e){await this._prepare();var t=await this.db._createStore(e,{},this.idbObjectStore.autoIncrement,this.idbObjectStore.indexNames),r=await this._getAllRecordsWithKeys();for(var s of r)await t._addRecord(s[1],s[0]);return t}_addRecord(e,t){return new Promise((async(r,s)=>{await this._prepare("readwrite");try{var n=this.idbObjectStore.add(e,t);n.onsuccess=e=>{r(e.target.result)},n.onerror=e=>{s(e.target.error)}}catch(e){s(e)}}))}async _clearAllRecords(){return await this._prepare("readwrite"),new Promise((async(e,t)=>{try{var r=this.idbObjectStore.clear();r.onsuccess=t=>{e()},r.onerror=e=>{t(e.target.error)}}catch(e){t(e)}}))}_getRecord(e){return new Promise((async(t,r)=>{await this._prepare();var s=this.idbObjectStore.get(e);s.onsuccess=s=>{var n=s.target.result;void 0!==n?t(n):r(new DOMException(`Key '${e}' doesn't exist in store '${this.name}'. To add a record with this key, use addRecord().`))},s.onerror=e=>{r(e.target.error)}}))}_getAllRecords(){return new Promise((async(e,t)=>{await this._prepare();var r=this.idbObjectStore.getAll();r.onsuccess=t=>{var r=t.target.result;e(r)},r.onerror=e=>{t(e.target.error)}}))}_getAllKeys(){return new Promise((async(e,t)=>{await this._prepare();var r=this.idbObjectStore.getAllKeys();r.onsuccess=t=>{var r=t.target.result;e(r)},r.onerror=e=>{t(e.target.error)}}))}async _getAllRecordsWithKeys(){var e=await this._getAllRecords(),t=await this._getAllKeys();return e.map(((e,r)=>[t[r],e]))}async _existsRecord(e){try{return await this._getRecord(e),!0}catch(e){return!1}}_deleteRecord(e){return new Promise((async(t,r)=>{if(await this._existsRecord(e)){await this._prepare("readwrite");var s=this.idbObjectStore.delete(e);s.onsuccess=e=>{t()},s.onerror=e=>{r(e.target.error)}}else r(new DOMException(`Key '${e}' doesn't exist in store '${this.name}'. To add a record with this key, use addRecord().`))}))}_updateRecord(e,t){return new Promise((async(r,s)=>{if(await this._existsRecord(e))if("object"==typeof t){var n=await this._getRecord(e),i=Object.assign(n,t);await this._prepare("readwrite");var o=this.idbObjectStore.put(i,e);o.onsuccess=e=>{r()},o.onerror=e=>{s(e.target.error)}}else s(new DOMException(`Second argument to updateRecord() must be an object. Currently, a '${typeof t}' was provided.`));else s(new DOMException(`Key '${e}' doesn't exist in store '${this.name}'. To add a record with this key, use addRecord().`))}))}_searchRecords(e,t,r=!1){return new Promise((async(s,n)=>{var i=(await this._getIndexes()).contains(e);await this._prepare(),s(await t.run(this.idbObjectStore,e,i,r))}))}async _searchRecordsAdvanced(t,r=!1){var s;for(var n in t){var i=t[n];s=e(await this._searchRecords(n,i),s)}if(!r)return s;var o=[];for(var a of s)o.push(await this._getRecord(a));return o}}class s{constructor(e,t,r){this.isIndexSearchCompatible=e,t instanceof IDBKeyRange?(this.idbKeyRange=t,this.recordMatcher=r):this.recordMatcher=t}runForIndexing(e,t,r){return new Promise(((s,n)=>{var i=e.index(t)[r?"getAll":"getAllKeys"](this.idbKeyRange);i.onsuccess=function(e){s(e.target.result)},i.onerror=function(e){n(e)}}))}runForLinearSearch(e,t,r){return new Promise(((s,n)=>{var i=[],o=e.openCursor();o.onsuccess=async e=>{var n=e.target.result;n?(this.recordMatcher(t,n.value)&&i.push(r?n.value:n.key),n.continue()):s(i)},o.onerror=e=>{n(e)}}))}async run(e,t,r,s){return r&&this.isIndexSearchCompatible?await this.runForIndexing(e,t,s):await this.runForLinearSearch(e,t,s)}}function n(e,t){return function(r){if("number"==typeof r||"string"==typeof r)return new s(!0,e(r),t.bind(null,r));throw new DOMException(`${e.name}() can only be called with a number or a string.`)}}const i=n((function(e){return IDBKeyRange.lowerBound(e,!0)}),((e,t,r)=>r[t]>e)),o=n((function(e){return IDBKeyRange.lowerBound(e)}),((e,t,r)=>r[t]>=e)),a=n((function(e){return IDBKeyRange.upperBound(e,!0)}),((e,t,r)=>r[t]<e)),c=n((function(e){return IDBKeyRange.upperBound(e)}),((e,t,r)=>r[t]<=e)),d=n((function(e){return IDBKeyRange.only(e)}),((e,t,r)=>r[t]===e));class h{static openConnections=[];static open(e){if(h.openConnections.includes(e))throw new DOMException(`Connection to database '${e}' already exists. A connection to a database must be closed before a new one can be opened.`);return h.openConnections.push(e),new Promise(((t,r)=>{var s=indexedDB.open(e);s.onsuccess=function(e){t(new h(e.target.result))},s.onerror=function(e){r(e)}}))}static async exists(e){return(await indexedDB.databases()).some((t=>t.name===e))}databaseActions=[];processingOn=!1;resolvingActionPromise=!1;constructor(e){this.idb=e,this.name=e.name,this.storeNames=e.objectStoreNames,this.stores={},this.deleted=!1,this.closed=!1,this.definePublicMethods()}definePublicMethods(){this.delete=this.getPublicMethodFunction(this._delete),this.existsStore=this.getPublicMethodFunction(this._existsStore),this.createStore=this.getPublicMethodFunction(this._createStore),this.getStore=this.getPublicMethodFunction(this._getStore),this.deleteStore=this.getPublicMethodFunction(this._deleteStore)}getPublicMethodFunction(e,t){var r=this;return function(){var s={},n=new Promise(((r,n)=>{s={function:e,store:t,arguments:Array.prototype.slice.call(arguments),resolve:r,reject:n}}));return r.queueDatabaseAction(s),n}}processNextDatabaseActionWhenFree(){setTimeout((async()=>{var e=this.databaseActions.shift();try{var t=await e.function.apply(e.store||this,e.arguments);this.resolvingActionPromise=!0,e.resolve(t)}catch(t){e.reject(t)}finally{setTimeout((()=>{this.resolvingActionPromise=!1,this.databaseActions.length?this.processNextDatabaseActionWhenFree():this.processingOn=!1}),0)}}),0)}queueDatabaseAction(e){this.resolvingActionPromise?this.databaseActions.unshift(e):this.databaseActions.push(e),this.processingOn||(this.processingOn=!0,this.processNextDatabaseActionWhenFree())}throwIfDeletedOrClosed(){if(this.deleted)throw new DOMException(`The underlying IndexedDB database '${this.name}' has been deleted. You'll have to create the database using Database.open(), and then use the returned Database instance to perform any further actions on the underlying database.`);if(this.closed)throw new DOMException(`The underlying IndexedDB database '${this.name}' has been closed. You'll have to open a new connection using Database.open(), and then use the returned Database instance to perform any further actions on the underlying database.`)}removeFromOpenConnections(){h.openConnections.splice(h.openConnections.indexOf(this.name),1)}close(){this.throwIfDeletedOrClosed(),this.removeFromOpenConnections(),this.idb.close()}_delete(){return this.throwIfDeletedOrClosed(),new Promise(((e,t)=>{this.close();var r=indexedDB.deleteDatabase(this.name);r.onsuccess=t=>{this.removeFromOpenConnections(),this.idb=null,this.stores={},this.deleted=!0,e()},r.onerror=e=>{t(e.target.error)}}))}_versionChange(e){return new Promise(((t,r)=>{this.close();var s=indexedDB.open(this.name,this.idb.version+1);s.onupgradeneeded=s=>{this.idb=s.target.result;try{var n=e();this.storeNames=this.idb.objectStoreNames,s.target.transaction.oncomplete=function(e){t(n)}}catch(s){r(s)}},s.onerror=function(e){r(e)}}))}createIDBStore(e,t,r){var s={};"boolean"==typeof t?s.autoIncrement=t:"string"==typeof t&&(s.keyPath=t);var n=this.idb.createObjectStore(e,s);if(r)for(var i of r)n.createIndex(i,i);return n}async _createStore(e,t,s,n){this.throwIfDeletedOrClosed(),await this._versionChange(this.createIDBStore.bind(this,e,s,n));var i=new r(this,e,t);return this.stores[e]=i,i}async getIDBObjectStore(e,t){return this.idb.transaction(e,t).objectStore(e)}async _getStore(e){if(this.throwIfDeletedOrClosed(),this.existsStore(e))return this.stores[e]||(this.stores[e]=new r(this,e)),this.stores[e];throw new DOMException(`Object store '${e}' doesn't exist. Create it first using createStore().`)}deleteIDBObjectStore(e){return this.idb.deleteObjectStore(e)}async _deleteStore(e){this.throwIfDeletedOrClosed(),await this._versionChange(this.deleteIDBObjectStore.bind(this,e)),delete this.stores[e]}async _existsStore(e){return this.throwIfDeletedOrClosed(),this.storeNames.contains(e)}}return h.isGreaterThan=i,h.isGreaterThanEqualTo=o,h.isLessThan=a,h.isLessThanEqualTo=c,h.isEqualTo=d,h.isLike=function(e,t=!1){if("string"!=typeof e)throw new DOMException("isLike() can only be called with strings.");var r=new RegExp("^"+e.replace(/%+/g,".*")+"$",t?"i":"");return new s(!1,(function(e,t){return r.test(t[e])}))},h.hasKeys=function(...e){return new s(!1,(function(t,r){var s=r[t];for(var n of e)if(!(n in s))return!1;return!0}))},h.FrontendDBStore=r,h}));
