!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).window=e.window||{})}(this,(function(e){"use strict";function t(e,t){if(!t)return e;var r=[],n=new Set(e);return t.forEach((function(e){n.has(e)&&r.push(e)})),r}class r{constructor(e,t,r){this.db=e,this.name=t,this.schema=r,this.idbObjectStore=null}prepare(e="readonly"){this.idbObjectStore=this.db.getIDBObjectStore(this.name,e)}getIndexes(){return this.prepare(),this.idbObjectStore.indexNames}async copy(e){this.prepare();var t=await this.db.createStore(e,{},this.idbObjectStore.autoIncrement,this.idbObjectStore.indexNames),r=await this.getAllRecordsWithKeys();for(var n of r)await t.addRecord(n[1],n[0]);return t}addRecord(e,t){return this.prepare("readwrite"),new Promise((async(r,n)=>{try{var s=this.idbObjectStore.add(e,t);s.onsuccess=e=>{r(e.target.result)},s.onerror=e=>{n(e.target.error)}}catch(e){n(e)}}))}async clearAllRecords(){return this.prepare("readwrite"),new Promise((async(e,t)=>{try{var r=this.idbObjectStore.clear();r.onsuccess=t=>{e()},r.onerror=e=>{t(e.target.error)}}catch(e){t(e)}}))}getRecord(e){return this.prepare(),new Promise((async(t,r)=>{var n=this.idbObjectStore.get(e);n.onsuccess=n=>{var s=n.target.result;void 0!==s?t(s):r(new DOMException(`Key '${e}' doesn't exist in store '${this.name}'. To add a record with this key, use addRecord().`))},n.onerror=e=>{r(e.target.error)}}))}getAllRecords(){return this.prepare(),new Promise((async(e,t)=>{var r=this.idbObjectStore.getAll();r.onsuccess=t=>{var r=t.target.result;e(r)},r.onerror=e=>{t(e.target.error)}}))}getAllKeys(){return this.prepare(),new Promise((async(e,t)=>{var r=this.idbObjectStore.getAllKeys();r.onsuccess=t=>{var r=t.target.result;e(r)},r.onerror=e=>{t(e.target.error)}}))}async getAllRecordsWithKeys(){var e=await this.getAllRecords(),t=await this.getAllKeys();return e.map(((e,r)=>[t[r],e]))}async existsRecord(e){try{return await this.getRecord(e),!0}catch(e){return!1}}deleteRecord(e){return new Promise((async(t,r)=>{if(await this.existsRecord(e)){this.prepare("readwrite");var n=this.idbObjectStore.delete(e);n.onsuccess=e=>{t()},n.onerror=e=>{r(e.target.error)}}else r(new DOMException(`Key '${e}' doesn't exist in store '${this.name}'. To add a record with this key, use addRecord().`))}))}updateRecord(e,t){return new Promise((async(r,n)=>{if(await this.existsRecord(e))if("object"==typeof t){var s=await this.getRecord(e),o=Object.assign(s,t);this.prepare("readwrite");var i=this.idbObjectStore.put(o,e);i.onsuccess=e=>{r()},i.onerror=e=>{n(e.target.error)}}else n(new DOMException(`Second argument to updateRecord() must be an object. Currently, a '${typeof t}' was provided.`));else n(new DOMException(`Key '${e}' doesn't exist in store '${this.name}'. To add a record with this key, use addRecord().`))}))}searchRecords(e,t,r=!1){var n=this.getIndexes().contains(e);return this.prepare(),new Promise((async(s,o)=>{s(await t.run(this.idbObjectStore,e,n,r))}))}async searchRecordsAdvanced(e,r=!1){var n;for(var s in e){var o=e[s];n=t(await this.searchRecords(s,o),n)}if(!r)return n;var i=[];for(var a of n)i.push(await this.getRecord(a));return i}}class n{constructor(e,t,r){this.isIndexSearchCompatible=e,t instanceof IDBKeyRange?(this.idbKeyRange=t,this.recordMatcher=r):this.recordMatcher=t}runForIndexing(e,t,r){return new Promise(((n,s)=>{var o=e.index(t)[r?"getAll":"getAllKeys"](this.idbKeyRange);o.onsuccess=function(e){n(e.target.result)},o.onerror=function(e){s(e)}}))}runForLinearSearch(e,t,r){return new Promise(((n,s)=>{var o=[],i=e.openCursor();i.onsuccess=async e=>{var s=e.target.result;s?(this.recordMatcher(t,s.value)&&o.push(r?s.value:s.key),s.continue()):n(o)},i.onerror=e=>{s(e)}}))}async run(e,t,r,n){return r&&this.isIndexSearchCompatible?await this.runForIndexing(e,t,n):await this.runForLinearSearch(e,t,n)}}function s(e,t){return function(r){if("number"==typeof r||"string"==typeof r)return new n(!0,e(r),t.bind(null,r));throw new DOMException(`${e.name}() can only be called with a number or a string.`)}}const o=s((function(e){return IDBKeyRange.lowerBound(e,!0)}),((e,t,r)=>r[t]>e)),i=s((function(e){return IDBKeyRange.lowerBound(e)}),((e,t,r)=>r[t]>=e)),a=s((function(e){return IDBKeyRange.upperBound(e,!0)}),((e,t,r)=>r[t]<e)),c=s((function(e){return IDBKeyRange.upperBound(e)}),((e,t,r)=>r[t]<=e)),d=s((function(e){return IDBKeyRange.only(e)}),((e,t,r)=>r[t]===e));class h{static openConnections=[];static open(e){return new Promise(((t,r)=>{if(h.openConnections.includes(e))throw new DOMException(`Connection to database '${e}' already exists. A connection to a database must be closed before a new one can be opened.`);var n=indexedDB.open(e);n.onsuccess=function(r){h.openConnections.push(e),t(new h(r.target.result))},n.onerror=function(e){r(e)}}))}static async exists(e){return(await indexedDB.databases()).some((t=>t.name===e))}constructor(e){this.idb=e,this.name=e.name,this.storeNames=e.objectStoreNames,this.stores={},this.deleted=!1,this.closed=!1}throwIfDeletedOrClosedOrClosed(){if(this.deleted)throw new DOMException(`The underlying IndexedDB database '${this.name}' has been deleted. You'll have to create the database using Database.open(), and then use the returned Database instance to perform any further actions on the underlying database.`);if(this.closed)throw new DOMException(`The underlying IndexedDB database '${this.name}' has been closed. You'll have to open a new connection using Database.open(), and then use the returned Database instance to perform any further actions on the underlying database.`)}removeFromOpenConnections(){h.openConnections.splice(h.openConnections.indexOf(this.name),1)}close(){this.throwIfDeletedOrClosedOrClosed(),this.removeFromOpenConnections(),this.idb.close()}delete(){return this.throwIfDeletedOrClosedOrClosed(),new Promise(((e,t)=>{this.close();var r=indexedDB.deleteDatabase(this.name);r.onsuccess=t=>{this.removeFromOpenConnections(),this.idb=null,this.stores={},this.deleted=!0,e()},r.onerror=e=>{t(e.target.error)}}))}versionChange(e){return new Promise(((t,r)=>{this.close();var n=indexedDB.open(this.name,this.idb.version+1);n.onupgradeneeded=n=>{this.idb=n.target.result;try{var s=e();this.storeNames=this.idb.objectStoreNames,n.target.transaction.oncomplete=function(e){t(s)}}catch(n){r(n)}},n.onerror=function(e){r(e)}}))}createIDBStore(e,t,r){var n={};"boolean"==typeof t?n.autoIncrement=t:"string"==typeof t&&(n.keyPath=t);var s=this.idb.createObjectStore(e,n);if(r)for(var o of r)s.createIndex(o,o);return s}async createStore(e,t,n,s){this.throwIfDeletedOrClosedOrClosed(),await this.versionChange(this.createIDBStore.bind(this,e,n,s));var o=new r(this,e,t);return this.stores[e]=o,o}getIDBObjectStore(e,t){return this.idb.transaction(e,t).objectStore(e)}getStore(e){if(this.throwIfDeletedOrClosedOrClosed(),this.existsStore(e))return this.stores[e]||(this.stores[e]=new r(this,e)),this.stores[e];throw new DOMException(`Object store '${e}' doesn't exist. Create it first using createStore().`)}deleteIDBObjectStore(e){return this.idb.deleteObjectStore(e)}async deleteStore(e){this.throwIfDeletedOrClosedOrClosed(),await this.versionChange(this.deleteIDBObjectStore.bind(this,e)),delete this.stores[e]}existsStore(e){return this.throwIfDeletedOrClosedOrClosed(),this.storeNames.contains(e)}}e.Database=h,e.DatabaseStore=r,e.default=h,e.hasKeys=function(...e){return new n(!1,(function(t,r){var n=r[t];for(var s of e)if(!(s in n))return!1;return!0}))},e.isEqualTo=d,e.isGreaterThan=o,e.isGreaterThanEqualTo=i,e.isLessThan=a,e.isLessThanEqualTo=c,e.isLike=function(e,t=!1){if("string"!=typeof e)throw new DOMException("isLike() can only be called with strings.");var r=new RegExp("^"+e.replace(/%+/g,".*")+"$",t?"i":"");return new n(!1,(function(e,t){return r.test(t[e])}))},Object.defineProperty(e,"__esModule",{value:!0})}));
